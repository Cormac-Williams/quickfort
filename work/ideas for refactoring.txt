

Hotkeys


GetCursorMoves(x, y, z) ; if x == -1, it would return "{L}"
GetCursorMovesDelta(x1, x2, y1, y2, z1, z2) ; delta move: if x1=0, x2=W, it would return "{R}{R}"

DataArray#
LoadDataFromFile()
ValidateFile()
ValidateCommandLine()

ShowIntroBox()

CorrectStartPosition()

ProcessRow()
  CurRow NumRows
ProcessCell()
  CurCol NumCols
RepeatPattern()

EVAL..
  output := ProcessRow(evalMode, evalCommands, "")

; let's just ProcessRows() and fuck the segmentation of the internal bits.
ProcessRows()
{
  global
}


; ProcessRow()
; commands = string of comma separated commands ending in #: d,h,d,#
; currentSubmenu = letter of current submenu (e.g. "C" if last command was "Cw"); if this is "" we aren't in a submenu
; initialMoves = any initial moves to make when positioning cursor before first command
; unsentMoves = any unsent moves will be returned by ProcessRow() in this variable, to be sent to the next iteration or just added at the end
ProcessRow(mode, commands, ByRef currentSubmenu, initialMoves, ByRef unsentMoves)
{
  output := ""
  nextMoves := ""
  
  Loop, parse, commands, `,
  {
    output := output . ProcessCell(mode, A_LoopField, nextMoves)
  }
}

ProcessCell(mode, commands, ByRef currentSubmenu, initialMoves, ByRef unsentMoves)
{
  
}

; Get initial key that needs to be sent before anything else (mode dependent, currently only b (build) requires this)
GetStartKey(mode)
{
  if (mode = "b")
    return "{Space}"
  else
    return ""
}

GetInputFile(filename, ByRef mode, ByRef fullMode, ByRef comment, ByRef width, ByRef height)
{
  GetFileDetails(file, mode, comment, width, height)
}
 
ProcessFile(filename, mode, startPos)
{
  output := output . GetStartKey(mode)
  currentSubmenu := ""

  ; Move from specified start corner to top left corner
  storedMoves := GetMovesFromCornerToCorner(startPos, 0)
    
  Loop, Read, filename
  {
    if %A_Index% = 1
      continue
    
    row := A_LoopReadLine
    
    ; process this row    
    output := output . ProcessRow(mode, row, currentSubmenu, storedMoves, storedMoves)
  }
  
  ; tack on any unsent moves (mode-safe)
  SendModeSafeMoves(...) ?
  
}
 
SetModeSpecifics(mode)
{ 
  global
     
  startKeys := ""

  if (mode = "b")
  {
    userInitKey = b o
    userInitText = build road
    startKeys := "{Space}"
    keyDelay := DelayMultiplier * 3
  }
  else if (mode = "d")
  {
    userInitKey = d
    userInitText = designations
    keyDelay := DelayMultiplier
  }
  else if (mode = "p")
  {
    userInitKey = p
    userInitText = stockpiles
    keyDelay := DelayMultiplier * 2
  }
  else if (mode = "q")
  {
    userInitKey = q
    userInitText = set building tasks/prefs
    keyDelay := DelayMultiplier * 2
  }
  else
  {
    MsgBox, Error: First line of .csv file must be one of: #dig #build #place #query (optionally followed by a space and a comment)`n`nUse Shift+Alt+Z to suspend/resume QF hotkeys.
    Exit
  }
}


ShowHowtoMouseTip()
{
  global userInitKey, userInitText, Tooltip

  ; Show howto mouse-tip
  Tooltip = TYPE %userInitKey% (%userInitText%). Position cursor with KEYBOARD.`nHit Alt+D to run script.`n`nAlt+Q/W/A/S changes starting corner.`nAlt+C cancels. Alt+R for repeat mode.
  TurnMouseTipOn()
}

; Get file details and return them in mode, fullMode, comment, width, height vars.
; Function itself will return a 1 if the file was valid, 0 if not.
GetFileDetails(file, ByRef mode, ByRef fullMode, ByRef comment, ByRef width, ByRef height)
{
      ; make sure we have a #mode line
      FileReadLine, firstline, %SelectedFile%, 1
      firstline := StripQuotes(firstline)
      
      if (!RegExMatch(firstline, "S)^#[dbqp]"))
      {
        MsgBox, Error: First line of .csv file must be one of: #dig #build #place #query (optionally followed by a space and a comment)`n`nUse Shift+Alt+Z to suspend/resume QF hotkeys.
        Exit
      }
  
      ; Extract mode and (optional) comment
      RegExMatch(firstline, "S)^#(\w+)( +.+)?", modeLineMatch)
      
      fullMode := modeLineMatch1
      mode := Substr(modeLineMatch1, 1, 1)
      
      comment := TrimSpaces(comment) ; trim spaces off
      comment := RegExReplace(modeLineMatch2, "S),{2,}") ; throw out unwanted strings of commas
      comment := RegExReplace(modeLineMatch2, "S),+$") ; discard any trailing commas
      comment := RegExReplace(comment, "S)\\n", "`n") ; Turn \\n into `n (AHK-style newline)
}

StripQuotes(str)
{
  return StringReplace, str, str, ", , 1
  return str
}

TrimSpaces(str)
{
  str := RegExReplace(str ,"S)^ +")
  str := RegExReplace(str ,"S) +$")
  
  return str
}

; alias substitution - currently only does exact match on whole value
SubstituteAliases(command)
{
  Loop %AliasArrayCount% {
    if (aliasArrayKey%A_Index% == command)
      action := aliasArrayValue%A_Index%
  }
  return command
}

; load aliases from AliasesPath
LoadAliases()
  global  ; Ensures our AliasArray# vars get created in global scope
  
  ; Load aliases from aliases.txt, if any
  AliasArrayCount := 0
  Log("`nLoading aliases..`n")
  Loop, Read, %AliasesPath%
  { 
    if (StrLen(A_LoopReadLine) <= 2 || SubStr(A_LoopReadLine, 1, 1) = "#")
      continue
  
    aliases1 = aliases2 = ""    
    StringSplit, aliases, A_LoopReadLine, `,
    
    ; drop leading or trailing spaces  
    aliases1 := RegExReplace(aliases1, "S)^\s*(.+)\s*$", "$1")
    aliases2 := RegExReplace(aliases2, "S)^\s*(.+)\s*$", "$1")  
    
    Log("`n" . aliases1 . ", " . aliases2)    
    aliasArrayKey%A_Index% := aliases1
    aliasArrayValue%A_Index% := aliases2
    aliasArrayCount := A_Index
  }
  Log("`n`nDone loading aliases.`n`n")
}


CleanUpKeystrokes(keys)
{
  if (!DisableKeyOptimizations)
    keys := OptimizeKeystrokes(keys)
  
  keys := TranslateKeystrokes(keys)
  
  return keys
}
 
TranslateKeystrokes(keys)
{
  ; Changes abbreviated {R} to {Right}, etc.
  StringReplace, keys, keys, {R}, {Right}, 1
  StringReplace, keys, keys, {L}, {Left}, 1
  StringReplace, keys, keys, {U}, {Up}, 1
  StringReplace, keys, keys, {D}, {Down}, 1

  keys := ConvertToNumpadKeys(keys)  
  
  return keys
}

ConvertToNumpadKeys(keys)
  ; let user use {/}{*}{-}{+} to refer to the equivalent numpad keys used by DF

  ; sub the {Numpad*} AHK codes for the 4 numpad operator abbreviations
  StringReplace, keys, keys, {/), {NumpadDiv}, 1
  StringReplace, keys, keys, {*), {NumpadMult}, 1
  StringReplace, keys, keys, {-), {NumpadSub}, 1
  StringReplace, keys, keys, {+), {NumpadAdd}, 1

  return keys
}

; Optimizations to eliminate several classes of movement redundancy.
OptimizeKeystrokes(keys)
{
  ; Turn {L}{D}{R} into {D}, {L}{D}{D}{R} into {D}{D}, etc.
  Loop 10
  {
    repeated := RepeatStr("{D}", A_Index)
    Loop 2 
    {
      check := (A_Index == 1 ? "{L}" : "{R}") . repeated . (A_Index == 1 ? "{R}" : "{L}")
      keys := RepeatReplace(keys, check, repeated)
      ;Loop
      ;{
      ;  StringReplace, keys, keys, %check%, %repeated%, UseErrorLevel
      ;  if ErrorLevel = 0
      ;    break
      ;}
    }
  }
    
  ; Remove instances of {R}{L}, etc. pairs repeatedly until all gone from keys (they'd just cancel one another out if actually sent).
  keys := RepeatReplace(keys, "{R}{L}", "")
  keys := RepeatReplace(keys, "{L}{R}", "")
  keys := RepeatReplace(keys, "{U}{D}", "")
  keys := RepeatReplace(keys, "{D}{U}", "")
  keys := RepeatReplace(keys, "{>}{<}", "")
  keys := RepeatReplace(keys, "{<}{>}", "")
  
  ; {R}{L}
  ;Loop {
  ;  StringReplace, keys, keys, {R}{L}, , UseErrorLevel
  ;  if (ErrorLevel = 0)
  ;    break
  ;}
  ; {L}{R}
  ;Loop {
  ;  StringReplace, keys, keys, {L}{R}, , UseErrorLevel
  ;  if (ErrorLevel = 0)
  ;    break
  ;}
  ; {U}{D}
  ;Loop {
  ;  StringReplace, keys, keys, {U}{D}, , UseErrorLevel
  ;  if (ErrorLevel = 0)
  ;    break
  ;}               
  ;; {D}{U}
  ;Loop {
  ;  StringReplace, keys, keys, {D}{U}, , UseErrorLevel
  ;  if (ErrorLevel = 0)
  ;    break
  ;}               
  ;; ><
  ;Loop {
  ;  StringReplace, keys, keys, ><, , UseErrorLevel
  ;  if (ErrorLevel = 0)
  ;    break
  ;}               
  ;; <>
  ;Loop {
  ;  StringReplace, keys, keys, <>, , UseErrorLevel
  ;  if (ErrorLevel = 0)
  ;    break
  ;}               
  
  ; Turn {R}x10 into +{R}|, etc. We insert a pipe symbol as a suffix to the replacement and will remove it after;
  ; it acts as a "bar" and makes sure we don't replace something that we just substituted-in during an earlier step.
  ;                           1  2  3  4  5  6  7  8  9  0
  StringReplace, keys, keys, {R}{R}{R}{R}{R}{R}{R}{R}{R}{R}, +{R}|, 1
  StringReplace, keys, keys, {L}{L}{L}{L}{L}{L}{L}{L}{L}{L}, +{L}|, 1
  StringReplace, keys, keys, {U}{U}{U}{U}{U}{U}{U}{U}{U}{U}, +{U}|, 1
  StringReplace, keys, keys, {D}{D}{D}{D}{D}{D}{D}{D}{D}{D}, +{D}|, 1
  
  ; Turn {R}x9 into +{R}{L}, etc. Could make this tidier with loops, but this'll do for now.
  ; Could run into problems using this optimization if you're building right next to the edge of the map,
  ; though it *should* still work fine since you can't build on the 3 tile "margin" around the edge anyway.
  ;                           1  2  3  4  5  6  7  8  9  0
  StringReplace, keys, keys, {R}{R}{R}{R}{R}{R}{R}{R}{R}, +{R}{L}|, 1
  StringReplace, keys, keys, {R}{R}{R}{R}{R}{R}{R}{R}, +{R}{L}{L}|, 1
  StringReplace, keys, keys, {R}{R}{R}{R}{R}{R}{R}, +{R}{L}{L}{L}|, 1
  StringReplace, keys, keys, {L}{L}{L}{L}{L}{L}{L}{L}{L}, +{L}{R}|, 1
  StringReplace, keys, keys, {L}{L}{L}{L}{L}{L}{L}{L}, +{L}{R}{R}|, 1
  StringReplace, keys, keys, {L}{L}{L}{L}{L}{L}{L}, +{L}{R}{R}{R}|, 1
  StringReplace, keys, keys, {U}{U}{U}{U}{U}{U}{U}{U}{U}, +{U}{D}|, 1
  StringReplace, keys, keys, {U}{U}{U}{U}{U}{U}{U}{U}, +{U}{D}{D}|, 1
  StringReplace, keys, keys, {U}{U}{U}{U}{U}{U}{U}, +{U}{D}{D}{D}|, 1
  StringReplace, keys, keys, {D}{D}{D}{D}{D}{D}{D}{D}{D}, +{D}{U}|, 1
  StringReplace, keys, keys, {D}{D}{D}{D}{D}{D}{D}{D}, +{D}{U}{U}|, 1
  StringReplace, keys, keys, {D}{D}{D}{D}{D}{D}{D}, +{D}{U}{U}{U}|, 1

  ; Remove the temporary bars.  
  StringReplace, keys, keys, |, , 1
}

; Keeps doing a replace on an input string until there are no more matches
RepeatReplace(haystack, needle, with)
{
   Loop {
    StringReplace, haystack, haystack, %needle%, %with%, UseErrorLevel
    if (ErrorLevel = 0)
      break
  }
  return haystack
}

; Sends the actual prepared keystroke output to DF.
; Sends it chunk style, breaking up Sends between % chars to give user a chance to cancel with Alt+C.
; If a chunk is just "wait" (i.e. %wait%) we'll sleep for a bit (used for CPU-heavy or interesting actions in DF).
SendKeyOutput(keys)
{
  global DebugOn, ReadyToGo, KeyDelay, DelayMultiplier
  
  if (!DebugOn)
  {
    ; Wait a moment before we start so keys are released by user.
    Sleep, 250
    Sleep, 0
    
    Loop, parse, output, `%
    { 
      SetKeyDelay, KeyDelay    
      Sleep, 0
      Sleep, KeyDelay
      if (!ReadyToGo)
      {
        ; build was cancelled by user.
        break
      }
      
      if (A_LoopField = "wait")
      {
        Sleep, (DelayMultiplier * 5)
      }
      else
      {
        Send %A_LoopField%
      }
    }
  }



; Return needed keystrokes to move the DF cursor the given number of units in the x, y, and z directions
; (negative numbers permitted). Positive direction for x, y, z is east, south, up respectively.
GetCursorMoves(x, y, z)
{
  return
    . (x > 0 ? RepeatStr("{R}", x) : RepeatStr("{L}", -x))
    . (y > 0 ? RepeatStr("{D}", y) : RepeatStr("{U}", -y))
    . (z > 0 ? RepeatStr("{<}", z) : RepeatStr("{>}", -z))
}
                      
; Moves from one (internal) corner of a certain width/height block to a different (internal) corner
; 01  <-- starting corner positions 0, 1, 2, 3
; 23
GetMovesFromCornerToCorner(startCorner, endCorner, width, height)
{
  keys := ""
  
  ; from L to R and v/v
  if (startCorner in (0, 2) && endCorner in (1, 3))
    keys := keys . GetCursorMoves(width - 1, 0, 0)
  else if (startCorner in (1, 3) && endCorner in (0, 2))
    keys := keys . GetCursorMoves(-width + 1, 0, 0)

  ; from top to bottom and v/v
  if (startCorner in (0, 1) && endCorner in (2, 3))
    keys := keys . GetCursorMoves(0, height - 1, 0)
  else if (startCorner in (2, 3) && endCorner in (0, 1))
    keys := keys . GetCursorMoves(0, -height + 1, 0)
    
  return keys
}
  
  
RepeatChunk(keys, repeatCount, repeatDir, startPos, width, height, zPos)
{  
  ; handle repeat mode
  ; ------------------
  ; if we're doing repeats (Alt+R) we handle it here. output is repeated and chained together with necessary movement commands
  ; to get to the correct next tile for each successive output.
  if (repeatCount > 1) {

    ; First we'll move to the starting position that was used on the initial placement; we need to start fom that same spot
    ; for each repetition.
    moves := "{U}" . GetMovesFromCornerToCorner(2, startPos, width, height)

    ;if(startPos == 1 or startPos == 3) ; we started on the right side so get back there
    ;  moves := moves . GetCursorMoves(xPos, 0, 0) ; RepeatStr("{R}", numcols)
    ;if(startPos == 0 or startPos == 1) ; we started on the top so get back there
    ;  moves := moves . GetCursorMoves(0, yPos, 0, 0)
  
    ; targetZPos is the Z-level, relative to the level we started the initial block on, that we want to be on in order to begin the
    ; next block. zPos contains the level we actually are on now, again relative to the initial block (0 = same level,
    ; 1 = one level above)
    if (repeatDir = "d" || repeatDir = "u") {
      ; next placement needs to occur on the z-level above or below the initial one. adjust targetZPos accordingly.
      ; To accommodate for multilevel blueprints, we multiply this z-level shift by the number of floors in the blueprint.
      targetZPos := (RepeatDir = "u" ? 1 : -1) * (1 + Abs(zPos))
    }
    else {
      ; repeating in a cardinal direction - we only need to start back on the same starting level as our initial start position (0)
      targetZPos := 0
    }

    ; Now make targetZPos relative to our CURRENT level, by subtracting our current level from it.
    targetZPos -= zPos
      
    ; Finally we can issue any moves needed to get onto the correct relative z-level
    moves := moves . GetCursorMoves(0, 0, targetZPos)
    
    ; Then move one of the four cardinal directions (exactly one 'block' away, touching the current block) or down/up (directly above or below)
    ;if (RepeatDir = "u")
    ;  moves := moves . "<"
    ;else if (RepeatDir = "d")
    ;  moves := moves . ">"
    ;else 
    if (RepeatDir in ("n", "s"))
      moves := moves . GetCursorMoves(0, numrows + 1, 0)
    if (RepeatDir in ("e", "w"))
      moves := moves . GetCursorMoves(0, numcols + 1, 0)
      
    ;if (RepeatDir in ("n")
    ;  moves := moves . RepeatStr("{U}", numrows + 1)
    ;else if (RepeatDir = "s")
    ;  moves := moves . RepeatStr("{D}", numrows + 1)
    ;else if (RepeatDir = "e")
    ;  moves := moves . RepeatStr("{R}", numcols + 1)
    ;else if (RepeatDir = "w")
    ;  moves := moves . RepeatStr("{L}", numcols + 1)
    
    ; @@@ put it all together
    ;if (Mode = "b")
    ;{ 
    ;  moves := moves
    ;}
    
    ; assemble the final result, plus tack on < or > Z-moves to get back to the initial z-level at the very end
    ; (lets us run multiple repeats)
    finalZMoves := GetCursorMoves(0, 0, -( (targetZLevel * (repeatCount - 1)) + (repeatCount * zPos) ) )
    return RepeatStr(keys . moves, repeatCount - 1) . keys . finalZMoves
  } 
  else if (repeatCount == 1)
  {
    return keys ; just the 1 repeat
  }
  else {
    ; repeatCount <= 0 so do nothing
    return ""
  }
}
  
repeat 3 up of a 2 block high blueprint
zl == -1 
== "depth" -2
== targetZ
5
4  xx3
3  xx3*
2  xx2
1  xx2
0  xx1
-1 xx1

rep=3,dir=up, zpos=-1, targetz=3,deep=2, dirsign=1
finalz=-((targetz*(rep-1))+(rep*zpos))
finalz=-((3*2)+(3*-1)) = -(6 - 3) = -3

1
0  x1
-1 x1
-2 x2
-3 x2
-4 x3
-5 x3
-6 x4
-7 x4*

rep=4, dir=down, deep=2, dirsign=-1, targetz=-1, zpos=-1
finalz=-((targetz*(rep-1))+(rep*zpos))
finalz=-((-1*(3))+(4*-1)) = -((-3)+(-4)) = --7 = 7


